<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanban Board - Nexus</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f4f5f7;
            min-height: 100vh;
            padding: 20px;
            transition: background-color 0.3s ease;
        }
        body.dark-mode {
            background: #1a1a1a;
            color: #e0e0e0;
        }
        body.dark-mode .column {
            background: #2d2d2d;
            color: #e0e0e0;
        }
        body.dark-mode .card {
            background: #333333;
            color: #e0e0e0;
            box-shadow: 0 1px 2px rgba(255,255,255,0.1);
        }
        body.dark-mode .card:hover { box-shadow: 0 2px 8px rgba(255,255,255,0.15); }
        body.dark-mode .add-task-btn,
        body.dark-mode .column-title,
        body.dark-mode .task-count { color: #b0b0b0; }
        body.dark-mode .add-task-btn:hover,
        body.dark-mode .column-title:hover { background: #404040; }
        body.dark-mode h1 { color: #e0e0e0; }
        body.dark-mode .backlog-container { background: #2d2d2d; }
        body.dark-mode .backlog-card { background: #3a3a3a; color: #e0e0e0; }
        body.dark-mode .backlog-card .bl-title { color: #e0e0e0; }
        body.dark-mode .backlog-card .bl-desc { color: #b0b0b0; }
        body.dark-mode .backlog-card .bl-link { color: #64b5f6; }
        body.dark-mode .bl-doc { background: #404040; }
        body.dark-mode .bl-doc a { color: #64b5f6; }
        body.dark-mode .spec-preview { background: #333; border-color: #555; }
        body.dark-mode .spec-task-item { background: #404040; }
        body.dark-mode input, body.dark-mode textarea { background: #333333; color: #e0e0e0; border: 1px solid #555; }
        body.dark-mode .modal-overlay .modal { background: #2d2d2d; color: #e0e0e0; border: 1px solid #555; }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        h1 { color: #172b4d; }

        /* â”€â”€ Backlog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .backlog-container {
            margin-bottom: 24px;
            padding: 16px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .backlog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .backlog-header h2 { font-size: 16px; color: #172b4d; }
        .backlog-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
            gap: 12px;
        }
        .backlog-card {
            background: #f0f5ff;
            border-left: 4px solid #0052cc;
            padding: 14px;
            border-radius: 4px;
            position: relative;
        }
        .backlog-card .bl-title {
            font-weight: 600;
            font-size: 15px;
            color: #172b4d;
            margin-bottom: 4px;
        }
        .backlog-card .bl-desc {
            color: #5e6c84;
            font-size: 13px;
            margin-bottom: 8px;
            white-space: pre-line;
        }
        .backlog-card .bl-link {
            color: #0052cc;
            text-decoration: none;
            font-size: 13px;
        }
        .bl-docs { margin: 6px 0; }
        .bl-doc {
            display: inline-block;
            background: #e4e8ef;
            padding: 2px 8px;
            border-radius: 3px;
            margin-right: 5px;
            margin-bottom: 3px;
            font-size: 12px;
        }
        .bl-doc a { color: #0052cc; text-decoration: none; }
        .bl-actions {
            display: flex;
            gap: 6px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .bl-btn {
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        .bl-btn-primary { background: #0052cc; color: white; }
        .bl-btn-primary:hover { background: #0065ff; }
        .bl-btn-success { background: #00875a; color: white; }
        .bl-btn-success:hover { background: #00a36c; }
        .bl-btn-danger { background: #de350b; color: white; }
        .bl-btn-danger:hover { background: #ff4422; }
        .bl-btn-secondary { background: #dfe1e6; color: #172b4d; }
        .bl-btn-secondary:hover { background: #c1c7d0; }
        .bl-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .bl-status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        .bl-status-none { background: #dfe1e6; color: #5e6c84; }
        .bl-status-generating { background: #fff0b3; color: #974f0c; }
        .bl-status-ready { background: #e3fcef; color: #006644; }
        .bl-status-approved { background: #deebff; color: #0747a6; }

        .bl-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #ddd;
            border-top-color: #0052cc;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            vertical-align: middle;
            margin-right: 4px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Spec Preview */
        .spec-preview {
            margin-top: 10px;
            padding: 10px;
            background: #fafbfc;
            border: 1px solid #dfe1e6;
            border-radius: 4px;
            font-size: 13px;
            max-height: 200px;
            overflow-y: auto;
        }
        .spec-preview pre {
            white-space: pre-wrap;
            word-break: break-word;
            font-family: inherit;
            margin: 0;
        }
        .spec-tasks-list { margin-top: 8px; }
        .spec-task-item {
            background: #e8ecf0;
            padding: 8px 10px;
            border-radius: 4px;
            margin-bottom: 4px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px;
        }
        .spec-task-item.released {
            opacity: 0.45;
            text-decoration: line-through;
        }
        .spec-task-item strong { font-weight: 600; }
        .spec-task-content { flex: 1; min-width: 0; }
        .spec-task-release-btn {
            flex-shrink: 0;
            background: #00875a;
            color: white;
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            white-space: nowrap;
        }
        .spec-task-release-btn:hover { background: #00a36c; }
        .spec-task-released-badge {
            flex-shrink: 0;
            background: #deebff;
            color: #0747a6;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
        }
        body.dark-mode .spec-task-item { background: #404040; }
        body.dark-mode .spec-task-item.released { opacity: 0.35; }
        body.dark-mode .spec-task-released-badge { background: #1a3a5c; color: #8cb4e0; }

        .spec-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            user-select: none;
            font-size: 12px;
            font-weight: 600;
            padding: 4px 0;
            color: #172b4d;
        }
        .spec-toggle:hover { color: #0052cc; }
        .spec-toggle-arrow {
            display: inline-block;
            transition: transform 0.2s;
            font-size: 10px;
        }
        .spec-toggle-arrow.open { transform: rotate(90deg); }
        .spec-collapsible {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .spec-collapsible.open {
            max-height: 5000px;
        }
        body.dark-mode .spec-toggle { color: #e0e0e0; }
        body.dark-mode .spec-toggle:hover { color: #64b5f6; }

        .doc-file-list { margin: 6px 0 12px; }
        .doc-file-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: #e4e8ef;
            padding: 4px 10px;
            border-radius: 12px;
            margin: 3px 4px 3px 0;
            font-size: 12px;
        }
        .doc-file-chip .doc-remove {
            cursor: pointer;
            opacity: 0.5;
            font-size: 14px;
            line-height: 1;
        }
        .doc-file-chip .doc-remove:hover { opacity: 1; }
        .doc-file-icon { font-size: 14px; }
        body.dark-mode .doc-file-chip { background: #404040; }

        .bl-delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            opacity: 0.3;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .backlog-card:hover .bl-delete-btn { opacity: 1; }
        .bl-delete-btn:hover { background: #ffbdad; }

        .backlog-empty {
            color: #5e6c84;
            font-size: 14px;
            padding: 20px;
            text-align: center;
        }

        /* â”€â”€ Modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-overlay .modal {
            background: white;
            border-radius: 8px;
            padding: 24px;
            min-width: 400px;
            max-width: 520px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.25);
        }
        .modal h3 { margin-bottom: 16px; }
        .modal label { display: block; font-size: 13px; font-weight: 600; margin-bottom: 4px; color: #5e6c84; }
        .modal input, .modal textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #dfe1e6;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 12px;
        }
        .modal textarea { min-height: 60px; resize: vertical; }
        .modal-doc-row {
            display: flex;
            gap: 8px;
            margin-bottom: 6px;
        }
        .modal-doc-row input { margin-bottom: 0; }
        .modal-buttons { display: flex; gap: 10px; margin-top: 16px; }
        .modal-buttons button { flex: 1; }

        /* â”€â”€ Board â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .board {
            display: flex;
            gap: 20px;
            overflow-x: auto;
            padding-bottom: 20px;
        }
        .column {
            background: #ebecf0;
            border-radius: 8px;
            min-width: 300px;
            max-width: 300px;
            padding: 12px;
        }
        .column-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .column-title {
            font-weight: 600;
            color: #172b4d;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .column-title:hover { background: #dfe1e6; }
        .task-count {
            color: #5e6c84;
            font-size: 12px;
        }
        .add-task-btn {
            width: 100%;
            padding: 8px;
            border: none;
            background: transparent;
            color: #5e6c84;
            cursor: pointer;
            border-radius: 4px;
            text-align: left;
        }
        .add-task-btn:hover { background: #dfe1e6; }
        .cards {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 50px;
        }
        .card {
            background: white;
            border-radius: 4px;
            padding: 10px 12px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            cursor: grab;
            transition: box-shadow 0.2s, transform 0.15s;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        .card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
        .card.dragging {
            opacity: 0.5;
            transform: scale(0.95);
            cursor: grabbing;
        }
        .card-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.85;
            transform: rotate(2deg);
            box-shadow: 0 8px 24px rgba(0,0,0,0.25);
            background: white;
            border-radius: 4px;
            padding: 10px 12px;
        }
        .drop-indicator {
            height: 3px;
            background: #0052cc;
            border-radius: 2px;
            margin: 2px 0;
            transition: opacity 0.15s;
        }
        .cards.drop-target {
            background: rgba(0,82,204,0.08);
            border-radius: 4px;
            min-height: 60px;
        }
        .card-title {
            margin-bottom: 8px;
            outline: none;
            word-break: break-word;
        }
        .card-title:focus { background: #fff3cd; }
        .card-desc {
            color: #5e6c84;
            font-size: 13px;
            outline: none;
            word-break: break-word;
        }
        .card-desc:focus { background: #f8f9fa; }
        .card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
        }
        .card-color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        .card-actions {
            display: flex;
            gap: 5px;
        }
        .attach-file-btn, .delete-btn {
            opacity: 0;
            background: #de350b;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        .card:hover .attach-file-btn, .card:hover .delete-btn { opacity: 1; }
        .attached-files {
            margin-top: 8px;
            font-size: 12px;
        }
        .attached-file {
            display: inline-block;
            background: #f4f5f7;
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 5px;
            margin-bottom: 3px;
        }
        .attached-file a {
            color: #0052cc;
            text-decoration: none;
        }
        .add-column-btn {
            min-width: 300px;
            padding: 12px;
            background: rgba(255,255,255,0.2);
            border: 2px dashed #dfe1e6;
            border-radius: 8px;
            color: #5e6c84;
            cursor: pointer;
            font-size: 14px;
        }
        .add-column-btn:hover { background: rgba(255,255,255,0.4); }

        /* â”€â”€ Agent Status Badges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .agent-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            margin-top: 6px;
        }
        .agent-badge-queued { background: #deebff; color: #0747a6; }
        .agent-badge-running { background: #fff0b3; color: #974f0c; }
        .agent-badge-review { background: #e3fcef; color: #006644; }
        .agent-badge-failed { background: #ffbdad; color: #bf2600; }
        .agent-badge .agent-spinner {
            display: inline-block;
            width: 10px; height: 10px;
            border: 2px solid #ddd;
            border-top-color: #974f0c;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        body.dark-mode .agent-badge-queued { background: #1a3a5c; color: #8cb4e0; }
        body.dark-mode .agent-badge-running { background: #5c4a1a; color: #e0c88c; }
        body.dark-mode .agent-badge-review { background: #1a4a33; color: #8ce0b4; }
        body.dark-mode .agent-badge-failed { background: #5c1a1a; color: #e08c8c; }

        .agent-send-btn {
            background: #6554c0;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            opacity: 0;
            position: relative;
        }
        .card:hover .agent-send-btn { opacity: 1; }
        .agent-send-btn:hover { background: #8777d9; }

        .agent-dropdown {
            position: absolute;
            bottom: 100%;
            right: 0;
            background: white;
            border: 1px solid #dfe1e6;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            min-width: 140px;
            padding: 4px 0;
        }
        body.dark-mode .agent-dropdown { background: #2d2d2d; border-color: #555; }
        .agent-dropdown-item {
            display: block;
            width: 100%;
            padding: 6px 12px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            font-size: 12px;
            color: inherit;
        }
        .agent-dropdown-item:hover { background: #f4f5f7; }
        .agent-dropdown-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .agent-dropdown-item.disabled:hover { background: none; }
        body.dark-mode .agent-dropdown-item:hover { background: #404040; }
        body.dark-mode .agent-dropdown-item.disabled:hover { background: none; }
        .agent-result-link {
            display: inline-block;
            margin-top: 4px;
            font-size: 11px;
            color: #0052cc;
            cursor: pointer;
            text-decoration: underline;
        }
        body.dark-mode .agent-result-link { color: #64b5f6; }

        /* Column drag handle */
        .column-drag-handle {
            cursor: grab;
            padding: 2px 4px;
            border-radius: 3px;
            color: #b0b0b0;
            font-size: 16px;
            line-height: 1;
            user-select: none;
        }
        .column-drag-handle:hover { background: #dfe1e6; color: #5e6c84; }
        body.dark-mode .column-drag-handle:hover { background: #404040; color: #ccc; }
        .column.col-dragging { opacity: 0.4; }
        .column-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.85;
            transform: rotate(1deg);
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            border-radius: 8px;
        }
        .col-drop-indicator {
            width: 4px;
            background: #0052cc;
            border-radius: 2px;
            min-height: 80px;
            align-self: stretch;
        }

        /* Edit Mode */
        .column-header.editing .column-title { display: none; }
        .column-header input {
            display: none;
            padding: 4px 8px;
            border: 2px solid #0052cc;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            background: white;
        }
        .column-header.editing input { display: block; }

        .add-btn {
            background: #0052cc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .add-btn:hover { background: #0065ff; }
    </style>
</head>
<body>
    <header>
        <h1>ğŸ“‹ Kanban Board</h1>
        <div style="display: flex; gap: 10px;">
            <button class="add-btn" onclick="openAddProjectModal()">+ Projekt</button>
            <button class="add-btn" onclick="addColumn()">+ Spalte</button>
            <button class="add-btn" onclick="toggleDarkMode()" style="background: #666;">ğŸŒ™ Dark</button>
        </div>
    </header>

    <div id="backlog-container"></div>

    <div class="board" id="board"></div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CONFIG
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const SPEC_SERVER = 'http://127.0.0.1:3002';

        // Project colors for approved tasks
        const PROJECT_COLORS = [
            '#4ecdc4', '#45b7d1', '#96ceb4', '#ff9ff3',
            '#54a0ff', '#feca57', '#ff6b6b', '#a29bfe'
        ];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let board = {
            columns: [
                { id: 1, title: 'To Do', tasks: [] },
                { id: 2, title: 'In Progress', tasks: [] },
                { id: 3, title: 'Done', tasks: [] }
            ],
            initiatives: [],
            backlog: []
        };

        // Polling timer for spec generation status
        let specPollTimers = {};

        // Track which project specs are expanded
        let specExpanded = {};

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PERSISTENCE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function save() {
            localStorage.setItem('kanban-board', JSON.stringify(board));
            fetch('/api/board', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(board)
            }).catch(err => console.log('Server save failed:', err.message));
        }

        async function loadBoard() {
            try {
                const response = await fetch('/api/board');
                if (response.ok) {
                    const serverBoard = await response.json();
                    board = serverBoard;
                    if (!board.backlog) board.backlog = [];
                    if (!board.initiatives) board.initiatives = [];
                    localStorage.setItem('kanban-board', JSON.stringify(board));
                } else {
                    const local = localStorage.getItem('kanban-board');
                    if (local) board = JSON.parse(local);
                }
            } catch (e) {
                const local = localStorage.getItem('kanban-board');
                if (local) board = JSON.parse(local);
            }
            if (!board.backlog) board.backlog = [];
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RENDER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function render() {
            renderBacklog();
            renderBoard();
        }

        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = board.columns.map(col => `
                <div class="column" data-id="${col.id}">
                    <div class="column-header">
                        <span class="column-drag-handle" title="Spalte verschieben">â ¿</span>
                        <span class="column-title" ondblclick="editColumnTitle(${col.id})">${col.title}</span>
                        <input type="text" value="${escAttr(col.title)}" onblur="saveColumnTitle(${col.id})" onkeypress="if(event.key==='Enter')saveColumnTitle(${col.id})">
                        <span class="task-count">${col.tasks.length}</span>
                    </div>
                    <div class="cards" data-column-id="${col.id}">
                        ${col.tasks.map(task => renderCard(col, task)).join('')}
                    </div>
                    <button class="add-task-btn" onclick="addTask(${col.id})">+ Task</button>
                </div>
            `).join('') + `<button class="add-column-btn" onclick="addColumn()">+ Spalte</button>`;
        }

        function renderCard(col, task) {
            const meta = parseAgentMetaFE(task.desc);
            const cleanDesc = getCleanDescFE(task.desc);
            const hiddenCols = ['queue', 'agent wip', 'review', 'done'];
            const isToDoCol = !hiddenCols.includes(col.title.toLowerCase());
            const agentBadge = renderAgentBadge(meta);
            const sendBtn = isToDoCol ? `<button class="agent-send-btn" onclick="showAgentDropdown(event, '${col.id}', '${task.id}')">â†’ Agent</button>` : '';

            return `
                <div class="card" data-task-id="${task.id}" data-column-id="${col.id}">
                    <div class="card-title" contenteditable="true" onblur="saveTaskTitle(${col.id},${task.id})">${esc(task.title)}</div>
                    <div class="card-desc" contenteditable="true" onblur="saveTaskDesc(${col.id},${task.id})">${esc(cleanDesc)}</div>
                    ${agentBadge}
                    <div class="card-footer">
                        <div style="display: flex; align-items: center;">
                            <span class="card-color-indicator" style="background-color: ${task.color || '#cccccc'};" title="${esc(task.colorLabel || 'Keine Farbe')}"></span>
                            <small style="color:#999">${task.created || task.createdAt ? new Date(task.created || task.createdAt).toLocaleDateString('de') : ''}</small>
                        </div>
                        <div class="card-actions">
                            ${sendBtn}
                            <button class="attach-file-btn" onclick="attachFile(${col.id}, ${task.id})">ğŸ“</button>
                            <button class="delete-btn" onclick="deleteTask(${col.id},${task.id})">âœ•</button>
                        </div>
                    </div>
                    ${task.files && task.files.length > 0 ? `
                    <div class="attached-files">
                        ${task.files.map(file => `
                            <span class="attached-file">
                                <a href="${escAttr(file.url)}" target="_blank">${esc(file.name)}</a>
                            </span>
                        `).join('')}
                    </div>` : ''}
                </div>
            `;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AGENT META (Frontend helpers)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function parseAgentMetaFE(description) {
            if (!description) return null;
            const idx = description.indexOf('---agent-meta---');
            if (idx === -1) return null;
            try { return JSON.parse(description.slice(idx + '---agent-meta---'.length).trim()); }
            catch { return null; }
        }

        function getCleanDescFE(description) {
            if (!description) return '';
            const idx = description.indexOf('---agent-meta---');
            return idx === -1 ? description : description.slice(0, idx).trim();
        }

        function setAgentMetaFE(description, meta) {
            const clean = getCleanDescFE(description);
            return clean + '\n\n---agent-meta---\n' + JSON.stringify(meta);
        }

        function renderAgentBadge(meta) {
            if (!meta || !meta.status) return '';
            const labels = {
                queued: 'In Warteschlange',
                running: `<span class="agent-spinner"></span> ${esc(meta.agent || '?')} arbeitet...`,
                review: 'Ergebnis prÃ¼fen',
                failed: `Fehlgeschlagen (${meta.attempts || '?'}/${3})`
            };
            const cls = `agent-badge agent-badge-${meta.status}`;
            return `<div class="${cls}">${labels[meta.status] || meta.status}</div>`;
        }

        // Agent registry cache (loaded from Task-Runner API)
        let agentRegistry = null;
        const TASK_RUNNER_URL = 'http://127.0.0.1:3004';

        async function loadAgentRegistry() {
            if (agentRegistry) return agentRegistry;
            try {
                const resp = await fetch(TASK_RUNNER_URL + '/api/agents');
                if (resp.ok) {
                    const data = await resp.json();
                    agentRegistry = data.agents || [];
                    return agentRegistry;
                }
            } catch (e) {
                console.log('Could not load agents from Task-Runner:', e.message);
            }
            // Fallback: hardcoded basics
            agentRegistry = [
                { id: 'claude', name: 'Claude Sonnet', enabled: true },
                { id: 'claude-opus', name: 'Claude Opus', enabled: true },
                { id: 'gemini', name: 'Gemini CLI', enabled: true },
                { id: 'openclaw', name: 'OpenClaw', enabled: true }
            ];
            return agentRegistry;
        }

        async function showAgentDropdown(event, colId, taskId) {
            event.stopPropagation();
            event.preventDefault();
            // Remove any existing dropdown
            document.querySelectorAll('.agent-dropdown').forEach(d => d.remove());

            const agents = await loadAgentRegistry();

            const btn = event.target;
            const rect = btn.getBoundingClientRect();
            const dropdown = document.createElement('div');
            dropdown.className = 'agent-dropdown';
            dropdown.style.position = 'fixed';
            dropdown.style.left = rect.left + 'px';
            dropdown.style.top = (rect.bottom + 4) + 'px';
            dropdown.style.zIndex = '9999';

            // Auto option first
            let html = `<button class="agent-dropdown-item" onmousedown="sendToAgent('${colId}', '${taskId}', null)">Auto (Keyword-Routing)</button>`;

            // Then all agents from config
            for (const agent of agents) {
                if (agent.enabled) {
                    html += `<button class="agent-dropdown-item" onmousedown="sendToAgent('${colId}', '${taskId}', '${agent.id}')">${esc(agent.name)}</button>`;
                } else {
                    const tooltip = agent.note ? ` title="${escAttr(agent.note)}"` : '';
                    html += `<button class="agent-dropdown-item disabled"${tooltip} disabled>${esc(agent.name)}</button>`;
                }
            }

            dropdown.innerHTML = html;
            document.body.appendChild(dropdown);

            // Close on click outside
            const close = (e) => {
                if (!dropdown.contains(e.target) && e.target !== btn) {
                    dropdown.remove();
                    document.removeEventListener('mousedown', close);
                }
            };
            setTimeout(() => document.addEventListener('mousedown', close), 50);
        }

        function sendToAgent(colId, taskId, agentChoice) {
            document.querySelectorAll('.agent-dropdown').forEach(d => d.remove());

            const col = board.columns.find(c => String(c.id) === String(colId));
            if (!col) return;
            const task = col.tasks.find(t => String(t.id) === String(taskId));
            if (!task) return;

            // Ensure Queue column exists
            let queueCol = board.columns.find(c => c.title === 'Queue');
            if (!queueCol) {
                queueCol = { id: Date.now(), title: 'Queue', tasks: [] };
                // Insert before Done or at end
                const doneIdx = board.columns.findIndex(c => c.title.toLowerCase() === 'done');
                if (doneIdx >= 0) board.columns.splice(doneIdx, 0, queueCol);
                else board.columns.push(queueCol);
            }

            // Set agent meta
            const meta = {
                agent: agentChoice, // null = auto-routing
                status: 'queued',
                attempts: 0,
                startedAt: null,
                resultPath: null,
                lastError: null
            };
            task.desc = setAgentMetaFE(task.desc, meta);

            // Move task from current column to Queue
            col.tasks = col.tasks.filter(t => String(t.id) !== String(taskId));
            queueCol.tasks.push(task);

            save();
            render();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BACKLOG RENDER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function renderBacklog() {
            const container = document.getElementById('backlog-container');
            const activeProjects = board.backlog.filter(p => p.specStatus !== 'approved');

            container.innerHTML = `
                <div class="backlog-container">
                    <div class="backlog-header">
                        <h2>ğŸ“¦ Backlog</h2>
                        <button class="add-btn" onclick="openAddProjectModal()" style="font-size:12px;padding:6px 12px;">+ Projekt</button>
                    </div>
                    ${activeProjects.length === 0
                        ? '<div class="backlog-empty">Keine Projekte im Backlog. Klicke "+ Projekt" um eins hinzuzufÃ¼gen.</div>'
                        : `<div class="backlog-grid">${activeProjects.map(p => renderBacklogCard(p)).join('')}</div>`
                    }
                </div>
            `;

            // Start polling for any generating projects
            activeProjects.filter(p => p.specStatus === 'generating').forEach(p => {
                startSpecPoll(p.id);
            });
        }

        function renderBacklogCard(p) {
            const statusLabel = {
                'none': 'Spec ausstehend',
                'generating': '<span class="bl-spinner"></span> Spec wird generiertâ€¦',
                'ready': 'Spec bereit',
                'approved': 'Freigegeben'
            };
            const statusClass = `bl-status-${p.specStatus}`;

            let specSection = '';
            if (p.specStatus === 'ready' && p.spec) {
                const specShort = p.spec.length > 300 ? p.spec.slice(0, 300) + 'â€¦' : p.spec;
                const releasedCount = (p.specTasks || []).filter(t => t.released).length;
                const totalTasks = (p.specTasks || []).length;
                const isOpen = specExpanded[p.id] ? 'open' : '';
                specSection = `
                    <div class="spec-toggle" onclick="toggleSpec('${p.id}')">
                        <span class="spec-toggle-arrow ${isOpen}">â–¶</span>
                        Spec & Tasks (${releasedCount}/${totalTasks} freigegeben)
                    </div>
                    <div class="spec-collapsible ${isOpen}">
                        <div class="spec-preview">
                            <pre>${esc(specShort)}</pre>
                        </div>
                        ${totalTasks > 0 ? `
                            <div class="spec-tasks-list">
                                ${p.specTasks.map((t, idx) => `
                                    <div class="spec-task-item${t.released ? ' released' : ''}">
                                        <div class="spec-task-content">
                                            <strong>${esc(t.title)}</strong><br>
                                            <span style="color:#5e6c84">${esc(t.details || '')}</span>
                                        </div>
                                        ${t.released
                                            ? '<span class="spec-task-released-badge">auf Board âœ“</span>'
                                            : `<button class="spec-task-release-btn" onclick="releaseTask('${p.id}', ${idx})">â†’ Board</button>`
                                        }
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            return `
                <div class="backlog-card" data-project-id="${p.id}">
                    <button class="bl-delete-btn" onclick="deleteProject('${p.id}')" title="LÃ¶schen">âœ•</button>
                    <span class="bl-status-badge ${statusClass}">${statusLabel[p.specStatus] || p.specStatus}</span>
                    <div class="bl-title">${esc(p.title)}</div>
                    <div class="bl-desc">${esc(p.description)}</div>
                    ${p.githubLink ? `<a href="${escAttr(p.githubLink)}" target="_blank" class="bl-link">GitHub â†’</a>` : ''}
                    ${p.documents && p.documents.length > 0 ? `
                        <div class="bl-docs">
                            ${p.documents.map(d => d.url
                                ? `<span class="bl-doc"><a href="${escAttr(d.url)}" target="_blank">ğŸ”— ${esc(d.name)}</a></span>`
                                : `<span class="bl-doc">ğŸ“ ${esc(d.name)}</span>`
                            ).join('')}
                        </div>
                    ` : ''}
                    ${specSection}
                    <div class="bl-actions">
                        ${p.specStatus === 'none' ? `<button class="bl-btn bl-btn-primary" onclick="generateSpec('${p.id}')">Spec erstellen</button>` : ''}
                        ${p.specStatus === 'generating' ? `<button class="bl-btn bl-btn-secondary" disabled>Generierung lÃ¤uftâ€¦</button>` : ''}
                        ${p.specStatus === 'ready' ? `
                            <button class="bl-btn bl-btn-success" onclick="approveProject('${p.id}')">Alle â†’ Board</button>
                            <button class="bl-btn bl-btn-secondary" onclick="generateSpec('${p.id}')">Neu generieren</button>
                        ` : ''}
                        <button class="bl-btn bl-btn-secondary" onclick="editProject('${p.id}')">Bearbeiten</button>
                    </div>
                </div>
            `;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BACKLOG ACTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function toggleSpec(projectId) {
            specExpanded[projectId] = !specExpanded[projectId];
            renderBacklog();
        }

        function openAddProjectModal() {
            showModal({
                title: 'Neues Projekt',
                fields: [
                    { id: 'title', label: 'Titel', type: 'input', required: true },
                    { id: 'description', label: 'Beschreibung', type: 'textarea' },
                    { id: 'githubLink', label: 'GitHub-Link', type: 'input', placeholder: 'https://github.com/...' },
                ],
                hasDocs: true,
                onSubmit: (data) => {
                    board.backlog.push({
                        id: 'proj-' + uid(),
                        title: data.title,
                        description: data.description || '',
                        githubLink: data.githubLink || '',
                        documents: data.documents || [],
                        specStatus: 'none',
                        spec: '',
                        specTasks: [],
                        createdAt: new Date().toISOString()
                    });
                    save();
                    render();
                }
            });
        }

        function editProject(projectId) {
            const p = board.backlog.find(x => x.id === projectId);
            if (!p) return;
            showModal({
                title: 'Projekt bearbeiten',
                fields: [
                    { id: 'title', label: 'Titel', type: 'input', value: p.title, required: true },
                    { id: 'description', label: 'Beschreibung', type: 'textarea', value: p.description },
                    { id: 'githubLink', label: 'GitHub-Link', type: 'input', value: p.githubLink },
                ],
                hasDocs: true,
                existingDocs: p.documents || [],
                onSubmit: (data) => {
                    p.title = data.title;
                    p.description = data.description || '';
                    p.githubLink = data.githubLink || '';
                    p.documents = data.documents || [];
                    save();
                    render();
                }
            });
        }

        function deleteProject(projectId) {
            if (!confirm('Projekt aus dem Backlog lÃ¶schen?')) return;
            board.backlog = board.backlog.filter(p => p.id !== projectId);
            save();
            render();
        }

        async function generateSpec(projectId) {
            const p = board.backlog.find(x => x.id === projectId);
            if (!p) return;

            try {
                // Set status on server FIRST via dedicated backlog endpoint
                const resp = await fetch('/api/backlog/' + projectId, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ specStatus: 'generating' })
                });
                if (!resp.ok) throw new Error('API Fehler: ' + resp.status);

                // Then update local state and render
                p.specStatus = 'generating';
                render();

                // Spec-Server on VPS polls for 'generating' projects and processes them
                startSpecPoll(projectId);
            } catch (err) {
                alert('Fehler beim Starten der Spec-Generierung: ' + err.message);
                p.specStatus = 'none';
                render();
            }
        }

        function startSpecPoll(projectId) {
            if (specPollTimers[projectId]) return;
            specPollTimers[projectId] = setInterval(async () => {
                try {
                    const resp = await fetch('/api/backlog/' + projectId);
                    if (!resp.ok) return;
                    const remote = await resp.json();
                    const local = board.backlog.find(x => x.id === projectId);
                    if (!local) { clearInterval(specPollTimers[projectId]); delete specPollTimers[projectId]; return; }
                    if (remote.specStatus !== 'generating') {
                        // Update local state
                        local.specStatus = remote.specStatus;
                        local.spec = remote.spec || '';
                        local.specTasks = remote.specTasks || [];
                        save();
                        render();
                        clearInterval(specPollTimers[projectId]);
                        delete specPollTimers[projectId];
                    }
                } catch (e) { /* continue polling */ }
            }, 5000);
        }

        function getProjectColor(projectId) {
            const idx = board.backlog.findIndex(x => x.id === projectId);
            return PROJECT_COLORS[idx % PROJECT_COLORS.length];
        }

        function ensureTodoColumn() {
            let todoCol = board.columns.find(c => c.title === 'To Do');
            if (!todoCol) {
                todoCol = { id: Date.now(), title: 'To Do', tasks: [] };
                board.columns.unshift(todoCol);
            }
            return todoCol;
        }

        function releaseTask(projectId, taskIndex) {
            const p = board.backlog.find(x => x.id === projectId);
            if (!p || !p.specTasks || !p.specTasks[taskIndex]) return;
            const t = p.specTasks[taskIndex];
            if (t.released) return;

            const todoCol = ensureTodoColumn();
            const color = getProjectColor(projectId);

            const titleText = `${p.title} â€” ${t.title}`;
            todoCol.tasks.push({
                id: Date.now(),
                title: titleText.length > 100 ? titleText.slice(0, 100) + 'â€¦' : titleText,
                desc: t.details || '',
                created: Date.now(),
                color: color,
                colorLabel: p.title,
                files: []
            });

            t.released = true;

            // If all tasks released, mark project as approved
            if (p.specTasks.every(st => st.released)) {
                p.specStatus = 'approved';
            }

            save();
            // Also update server-side backlog
            fetch('/api/backlog/' + projectId, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ specTasks: p.specTasks, specStatus: p.specStatus })
            }).catch(() => {});
            render();
        }

        function approveProject(projectId) {
            const p = board.backlog.find(x => x.id === projectId);
            if (!p || p.specStatus !== 'ready') return;

            const todoCol = ensureTodoColumn();
            const color = getProjectColor(projectId);

            // Release all unreleased tasks
            (p.specTasks || []).forEach((t, i) => {
                if (t.released) return;
                const titleText = `${p.title} â€” ${t.title}`;
                todoCol.tasks.push({
                    id: Date.now() + i + 1,
                    title: titleText.length > 100 ? titleText.slice(0, 100) + 'â€¦' : titleText,
                    desc: t.details || '',
                    created: Date.now(),
                    color: color,
                    colorLabel: p.title,
                    files: []
                });
                t.released = true;
            });

            // Mark as approved
            p.specStatus = 'approved';
            save();
            fetch('/api/backlog/' + projectId, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ specTasks: p.specTasks, specStatus: p.specStatus })
            }).catch(() => {});
            render();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MODAL
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Pending files for modal
        let modalPendingDocs = [];

        function showModal({ title, fields, hasDocs, existingDocs, onSubmit }) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            modalPendingDocs = existingDocs ? [...existingDocs] : [];

            let docsHTML = '';
            if (hasDocs) {
                docsHTML = `
                    <label>Dokumente</label>
                    <div id="modal-doc-list" class="doc-file-list"></div>
                    <div style="display:flex;gap:6px;margin-bottom:12px;">
                        <button type="button" class="bl-btn bl-btn-secondary" id="modal-add-files">ğŸ“ Dateien wÃ¤hlen</button>
                        <button type="button" class="bl-btn bl-btn-secondary" id="modal-add-url">ğŸ”— URL hinzufÃ¼gen</button>
                    </div>
                    <input type="file" id="modal-file-input" multiple accept=".txt,.md,.json,.yaml,.yml,.xml,.csv,.html,.htm,.pdf,.docx,.py,.js,.ts,.jsx,.tsx,.css,.sql,.sh,.toml,.ini,.cfg,.log,.rtf" style="display:none">
                `;
            }

            overlay.innerHTML = `
                <div class="modal">
                    <h3>${title}</h3>
                    ${fields.map(f => `
                        <label>${f.label}${f.required ? ' *' : ''}</label>
                        ${f.type === 'textarea'
                            ? `<textarea id="modal-${f.id}" placeholder="${f.placeholder || ''}">${esc(f.value || '')}</textarea>`
                            : `<input type="text" id="modal-${f.id}" value="${escAttr(f.value || '')}" placeholder="${f.placeholder || ''}">`
                        }
                    `).join('')}
                    ${docsHTML}
                    <div class="modal-buttons">
                        <button class="bl-btn bl-btn-primary" id="modal-submit">Speichern</button>
                        <button class="bl-btn bl-btn-secondary" id="modal-cancel">Abbrechen</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);
            overlay.querySelector('#modal-cancel').onclick = () => overlay.remove();

            if (hasDocs) {
                renderModalDocs();
                overlay.querySelector('#modal-add-files').onclick = () => {
                    overlay.querySelector('#modal-file-input').click();
                };
                overlay.querySelector('#modal-file-input').onchange = async (e) => {
                    const files = Array.from(e.target.files);
                    for (const file of files.slice(0, 10)) {
                        if (modalPendingDocs.length >= 10) break;
                        try {
                            const content = await readFileContent(file);
                            modalPendingDocs.push({ name: file.name, content, size: file.size });
                        } catch (err) {
                            modalPendingDocs.push({ name: file.name, content: '(Konnte nicht gelesen werden)', size: file.size });
                        }
                    }
                    e.target.value = '';
                    renderModalDocs();
                };
                overlay.querySelector('#modal-add-url').onclick = () => {
                    const url = prompt('Dokument-URL eingeben:');
                    if (url && url.trim()) {
                        const name = url.split('/').pop() || 'Dokument';
                        modalPendingDocs.push({ name, url: url.trim() });
                        renderModalDocs();
                    }
                };
            }

            overlay.querySelector('#modal-submit').onclick = () => {
                const data = {};
                for (const f of fields) {
                    data[f.id] = document.getElementById('modal-' + f.id).value.trim();
                }
                if (fields.some(f => f.required && !data[f.id])) {
                    alert('Bitte Pflichtfelder ausfÃ¼llen.');
                    return;
                }
                if (hasDocs) {
                    data.documents = modalPendingDocs;
                }
                onSubmit(data);
                overlay.remove();
            };
            const firstInput = overlay.querySelector('input[type="text"], textarea');
            if (firstInput) firstInput.focus();
        }

        function renderModalDocs() {
            const container = document.getElementById('modal-doc-list');
            if (!container) return;
            if (modalPendingDocs.length === 0) {
                container.innerHTML = '<span style="color:#999;font-size:12px;">Keine Dokumente angehÃ¤ngt</span>';
                return;
            }
            container.innerHTML = modalPendingDocs.map((d, i) => {
                const icon = d.url ? 'ğŸ”—' : fileIcon(d.name);
                const info = d.url ? d.url.slice(0, 40) : formatSize(d.size);
                return `<span class="doc-file-chip">
                    <span class="doc-file-icon">${icon}</span>
                    ${esc(d.name)}
                    <span style="color:#999;font-size:10px;">(${info})</span>
                    <span class="doc-remove" onclick="removeModalDoc(${i})">âœ•</span>
                </span>`;
            }).join('');
        }

        window.removeModalDoc = function(idx) {
            modalPendingDocs.splice(idx, 1);
            renderModalDocs();
        };

        function fileIcon(name) {
            const ext = name.split('.').pop().toLowerCase();
            const icons = { pdf: 'ğŸ“„', md: 'ğŸ“', txt: 'ğŸ“ƒ', json: 'ğŸ“‹', yaml: 'âš™ï¸', yml: 'âš™ï¸',
                           py: 'ğŸ', js: 'ğŸ“œ', ts: 'ğŸ“œ', html: 'ğŸŒ', css: 'ğŸ¨', csv: 'ğŸ“Š', xml: 'ğŸ“¦' };
            return icons[ext] || 'ğŸ“';
        }

        function formatSize(bytes) {
            if (!bytes) return '';
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const maxSize = 50000; // 50KB text limit
                if (file.size > 2 * 1024 * 1024) {
                    resolve(`(Datei zu groÃŸ: ${formatSize(file.size)} â€” max 2MB)`);
                    return;
                }
                const reader = new FileReader();
                reader.onload = () => {
                    let text = reader.result;
                    if (text.length > maxSize) {
                        text = text.slice(0, maxSize) + '\nâ€¦(gekÃ¼rzt, ' + formatSize(file.size) + ' gesamt)';
                    }
                    resolve(text);
                };
                reader.onerror = () => reject(reader.error);
                reader.readAsText(file);
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BOARD ACTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function addColumn() {
            const title = prompt('Spaltenname:');
            if (title) {
                board.columns.push({ id: Date.now(), title: title, tasks: [] });
                save();
                render();
            }
        }

        function editColumnTitle(id) {
            const col = document.querySelector(`.column[data-id="${id}"]`);
            col.querySelector('.column-header').classList.add('editing');
            col.querySelector('input').focus();
        }

        function saveColumnTitle(id) {
            const col = document.querySelector(`.column[data-id="${id}"]`);
            const input = col.querySelector('input');
            const column = board.columns.find(c => c.id === id);
            column.title = input.value;
            col.querySelector('.column-header').classList.remove('editing');
            save();
            render();
        }

        function addTask(colId) {
            const title = prompt('Task Titel:');
            if (title) {
                const column = board.columns.find(c => c.id === colId);
                column.tasks.push({
                    id: Date.now(),
                    title: title,
                    desc: '',
                    created: Date.now(),
                    color: '#cccccc',
                    colorLabel: 'Standard',
                    files: []
                });
                save();
                render();
            }
        }

        function saveTaskTitle(colId, taskId) {
            const column = board.columns.find(c => c.id === colId);
            const task = column.tasks.find(t => t.id === taskId);
            task.title = event.target.innerText;
            save();
        }

        function saveTaskDesc(colId, taskId) {
            const column = board.columns.find(c => c.id === colId);
            const task = column.tasks.find(t => t.id === taskId);
            task.desc = event.target.innerText;
            save();
        }

        function deleteTask(colId, taskId) {
            if (confirm('Task lÃ¶schen?')) {
                const column = board.columns.find(c => c.id === colId);
                column.tasks = column.tasks.filter(t => t.id !== taskId);
                save();
                render();
            }
        }

        function attachFile(colId, taskId) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:white;padding:20px;border:1px solid #ccc;border-radius:8px;z-index:1000;box-shadow:0 4px 16px rgba(0,0,0,0.25);display:flex;flex-direction:column;gap:10px;min-width:320px;';
            if (document.body.classList.contains('dark-mode')) {
                modal.style.background = '#2d2d2d';
                modal.style.border = '1px solid #555';
                modal.style.color = '#e0e0e0';
            }

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.placeholder = 'Dateiname / Bezeichnung';
            nameInput.style.cssText = 'padding:8px;border:1px solid #ccc;border-radius:4px;';

            const urlInput = document.createElement('input');
            urlInput.type = 'url';
            urlInput.placeholder = 'URL (https://...)';
            urlInput.style.cssText = 'padding:8px;border:1px solid #ccc;border-radius:4px;';

            const btnRow = document.createElement('div');
            btnRow.style.cssText = 'display:flex;gap:10px;margin-top:5px;';

            const addBtn = document.createElement('button');
            addBtn.textContent = 'HinzufÃ¼gen';
            addBtn.style.cssText = 'flex:1;background:#0052cc;color:white;border:none;padding:8px;border-radius:4px;cursor:pointer;';
            addBtn.onclick = function() {
                const name = nameInput.value.trim();
                const url = urlInput.value.trim();
                if (!name || !url) { alert('Bitte Name und URL eingeben!'); return; }
                const column = board.columns.find(c => c.id === colId);
                const task = column ? column.tasks.find(t => t.id === taskId) : null;
                if (!task) { alert('Task nicht gefunden'); modal.remove(); return; }
                if (!task.files) task.files = [];
                task.files.push({ name, url });
                save();
                render();
                modal.remove();
            };

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Abbrechen';
            cancelBtn.style.cssText = 'flex:1;background:#de350b;color:white;border:none;padding:8px;border-radius:4px;cursor:pointer;';
            cancelBtn.onclick = function() { modal.remove(); };

            const title = document.createElement('h3');
            title.textContent = 'Link hinzufÃ¼gen';
            title.style.margin = '0 0 5px 0';

            btnRow.append(addBtn, cancelBtn);
            modal.append(title, nameInput, urlInput, btnRow);
            document.body.appendChild(modal);
            nameInput.focus();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UTILITIES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function uid() {
            return Math.random().toString(36).slice(2, 10);
        }

        function esc(s) {
            const d = document.createElement('div');
            d.textContent = s;
            return d.innerHTML;
        }

        function escAttr(s) {
            return (s || '').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode') ? 'enabled' : 'disabled');
        }

        function initDarkMode() {
            if (localStorage.getItem('darkMode') === 'enabled') {
                document.body.classList.add('dark-mode');
            }
        }

        initDarkMode();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DRAG & DROP via Pointer Events
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let dnd = {
            active: false, card: null, ghost: null, indicator: null,
            taskId: null, originColId: null, originIdx: null,
            startX: 0, startY: 0, offsetX: 0, offsetY: 0
        };

        // Column drag state
        let colDnd = {
            active: false, column: null, ghost: null, indicator: null,
            originIdx: null, startX: 0, startY: 0, offsetX: 0, offsetY: 0
        };

        function initDragDrop() {
            document.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
        }

        function onPointerDown(e) {
            const tag = e.target.tagName;
            if (tag === 'BUTTON' || tag === 'INPUT' || tag === 'A') return;
            if (e.target.isContentEditable) return;

            // Column drag: initiated from drag handle
            if (e.target.closest('.column-drag-handle')) {
                const column = e.target.closest('.column');
                if (!column) return;
                const colId = column.dataset.id;
                colDnd.startX = e.clientX;
                colDnd.startY = e.clientY;
                colDnd.column = column;
                colDnd.originIdx = board.columns.findIndex(c => String(c.id) === String(colId));
                const rect = column.getBoundingClientRect();
                colDnd.offsetX = e.clientX - rect.left;
                colDnd.offsetY = e.clientY - rect.top;
                return;
            }

            // Card drag
            const card = e.target.closest('.card');
            if (!card) return;

            dnd.startX = e.clientX;
            dnd.startY = e.clientY;
            dnd.card = card;
            dnd.taskId = parseInt(card.dataset.taskId);
            dnd.originColId = parseInt(card.closest('.column').dataset.id);
            const col = board.columns.find(c => c.id === dnd.originColId);
            if (col) dnd.originIdx = col.tasks.findIndex(t => t.id === dnd.taskId);

            const rect = card.getBoundingClientRect();
            dnd.offsetX = e.clientX - rect.left;
            dnd.offsetY = e.clientY - rect.top;
        }

        function onPointerMove(e) {
            // Column drag
            if (colDnd.column) {
                if (!colDnd.active) {
                    const dx = e.clientX - colDnd.startX;
                    if (Math.abs(dx) < 8) return;
                    colDnd.active = true;
                    colDnd.column.classList.add('col-dragging');
                    colDnd.ghost = colDnd.column.cloneNode(true);
                    colDnd.ghost.className = 'column column-ghost';
                    colDnd.ghost.style.width = colDnd.column.offsetWidth + 'px';
                    colDnd.ghost.style.height = colDnd.column.offsetHeight + 'px';
                    document.body.appendChild(colDnd.ghost);
                    colDnd.indicator = document.createElement('div');
                    colDnd.indicator.className = 'col-drop-indicator';
                }
                colDnd.ghost.style.left = (e.clientX - colDnd.offsetX) + 'px';
                colDnd.ghost.style.top = (e.clientY - colDnd.offsetY) + 'px';

                // Find target column position
                colDnd.ghost.style.display = 'none';
                const el = document.elementFromPoint(e.clientX, e.clientY);
                colDnd.ghost.style.display = '';
                if (colDnd.indicator.parentNode) colDnd.indicator.remove();

                if (el) {
                    const targetCol = el.closest('.column');
                    if (targetCol && targetCol !== colDnd.column) {
                        const rect = targetCol.getBoundingClientRect();
                        const boardEl = document.getElementById('board');
                        if (e.clientX < rect.left + rect.width / 2) {
                            boardEl.insertBefore(colDnd.indicator, targetCol);
                        } else {
                            targetCol.after(colDnd.indicator);
                        }
                    }
                }
                return;
            }

            if (!dnd.card) return;
            if (!dnd.active) {
                const dx = e.clientX - dnd.startX;
                const dy = e.clientY - dnd.startY;
                if (Math.abs(dx) < 5 && Math.abs(dy) < 5) return;

                dnd.active = true;
                dnd.card.classList.add('dragging');
                dnd.card.setPointerCapture(e.pointerId);

                dnd.ghost = document.createElement('div');
                dnd.ghost.className = 'card-ghost';
                dnd.ghost.innerHTML = dnd.card.querySelector('.card-title').textContent;
                dnd.ghost.style.width = dnd.card.offsetWidth + 'px';
                document.body.appendChild(dnd.ghost);

                dnd.indicator = document.createElement('div');
                dnd.indicator.className = 'drop-indicator';
            }

            dnd.ghost.style.left = (e.clientX - dnd.offsetX) + 'px';
            dnd.ghost.style.top = (e.clientY - dnd.offsetY) + 'px';

            dnd.ghost.style.display = 'none';
            const elBelow = document.elementFromPoint(e.clientX, e.clientY);
            dnd.ghost.style.display = '';

            if (dnd.indicator.parentNode) dnd.indicator.remove();
            document.querySelectorAll('.cards.drop-target').forEach(c => c.classList.remove('drop-target'));

            if (!elBelow) return;
            const targetCardsContainer = elBelow.closest('.cards');
            if (!targetCardsContainer) return;
            targetCardsContainer.classList.add('drop-target');

            const targetCard = elBelow.closest('.card');
            if (targetCard && targetCard !== dnd.card) {
                const rect = targetCard.getBoundingClientRect();
                if (e.clientY < rect.top + rect.height / 2) {
                    targetCard.before(dnd.indicator);
                } else {
                    targetCard.after(dnd.indicator);
                }
            } else if (!targetCard) {
                targetCardsContainer.appendChild(dnd.indicator);
            }
        }

        function onPointerUp(e) {
            // Column drop
            if (colDnd.column) {
                if (colDnd.active) {
                    colDnd.column.classList.remove('col-dragging');
                    if (colDnd.ghost) colDnd.ghost.style.display = 'none';
                    const el = document.elementFromPoint(e.clientX, e.clientY);
                    if (colDnd.ghost) colDnd.ghost.remove();
                    if (colDnd.indicator) colDnd.indicator.remove();

                    if (el) {
                        const targetCol = el.closest('.column');
                        if (targetCol && targetCol !== colDnd.column) {
                            const targetId = targetCol.dataset.id;
                            let targetIdx = board.columns.findIndex(c => String(c.id) === String(targetId));
                            const rect = targetCol.getBoundingClientRect();
                            if (e.clientX >= rect.left + rect.width / 2) targetIdx += 1;
                            // Move column in data
                            const [moved] = board.columns.splice(colDnd.originIdx, 1);
                            // Adjust target if it shifted
                            if (colDnd.originIdx < targetIdx) targetIdx -= 1;
                            board.columns.splice(targetIdx, 0, moved);
                            save();
                            render();
                        }
                    }
                }
                colDnd = { active: false, column: null, ghost: null, indicator: null,
                           originIdx: null, startX: 0, startY: 0, offsetX: 0, offsetY: 0 };
                return;
            }

            if (!dnd.card) return;

            if (dnd.active) {
                dnd.card.classList.remove('dragging');
                dnd.card.releasePointerCapture(e.pointerId);

                if (dnd.ghost) dnd.ghost.style.display = 'none';
                const elBelow = document.elementFromPoint(e.clientX, e.clientY);
                if (dnd.ghost) dnd.ghost.remove();
                if (dnd.indicator) dnd.indicator.remove();

                document.querySelectorAll('.cards.drop-target').forEach(c => c.classList.remove('drop-target'));

                if (elBelow) {
                    const targetCardsContainer = elBelow.closest('.cards');
                    if (targetCardsContainer) {
                        const targetColId = parseInt(targetCardsContainer.dataset.columnId);
                        const originCol = board.columns.find(c => c.id === dnd.originColId);
                        const destCol = board.columns.find(c => c.id === targetColId);

                        if (originCol && destCol) {
                            const movedTask = originCol.tasks.splice(dnd.originIdx, 1)[0];
                            const targetCard = elBelow.closest('.card');
                            if (targetCard && targetCard !== dnd.card) {
                                const targetTaskId = parseInt(targetCard.dataset.taskId);
                                let insertIdx = destCol.tasks.findIndex(t => t.id === targetTaskId);
                                const rect = targetCard.getBoundingClientRect();
                                if (e.clientY >= rect.top + rect.height / 2) insertIdx += 1;
                                destCol.tasks.splice(insertIdx, 0, movedTask);
                            } else {
                                destCol.tasks.push(movedTask);
                            }
                            save();
                            render();
                        }
                    }
                }
            }

            dnd = { active: false, card: null, ghost: null, indicator: null,
                    taskId: null, originColId: null, originIdx: null,
                    startX: 0, startY: 0, offsetX: 0, offsetY: 0 };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INIT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        loadBoard().then(() => { render(); initDragDrop(); loadAgentRegistry(); });
    </script>
</body>
</html>
